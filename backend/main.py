from flask import Flask, jsonify
from flask_cors import CORS
import pandas as pd
import csv
from wmd import WMD
from LLM import get_ideal_profiles
import re

app = Flask(__name__)
CORS(app)

def getDesignations(designation):
    designations = []
    if(designation[0] == '1'):
        designations.append("ceo")
    if(designation[1] == "1"):
        designations.append("cto")
    if(designation[2] == "1"):
        designations.append("cmo")
    return designations
    
def test(idea, designation):
    # designations = getDesignations(designation)
    
    # res = {}
    
    # for role in designations:
    #     print(role)
    #     file = open(f"./resources/Ideas/{idea}/{idea}_{role}.txt", "r")
    #     res[role] = file.read()
    
    # print(res)

    # name = "PRAMOD GAIKWAD"
    # with open(f'./Profile/ceo/{name}.txt', 'r', encoding="utf-8") as f:
    #         profile = f.read()
    #         profile  = profile.replace("\n"," ")
    #         linkedin = re.search(r'Contact\s(.*?)\s\(LinkedIn\)', profile.strip()).group(1).replace(" ","")
    #         print(linkedin)
    role = "ceo"
    wmd = WMD("123",f"./Communities/{role}_community")
    wmd.wmd_community(role)

@app.route('/<idea>/<designation>')
def main(idea, designation):
    designations = getDesignations(designation)
    if len(designations)==0:
        return jsonify({"error":"Error has occured"})

    # LLM Prompter
    res = get_ideal_profiles(idea=idea,designations=designations)

    # WMD Working
    final_results = {}
    for role,description in res.items():
        if description == "":
            continue

        # for person profiles
        wmd = WMD(description, f"./Profile/{role}")
        top_5_profiles = wmd.person_ranking()
        
        profile_results = {}
        # TODO: a list of exactly 5 profile names any name from LLM
        # For eg:- profile_name_list = generate_profile_names()
        # profile_name_list will contain structure like ['Name1', 'Name2', 'Name3', 'Name4', 'Name5']
        for i, (profile_name, similarity_score) in enumerate(top_5_profiles, 1):
            print(f"Top {i} Profile (Similarity Score: {similarity_score}): {profile_name}")
            if role not in final_results:
                final_results[role] = []
            profile_results[profile_name] = similarity_score
            final_results[role].append(["profile_name", similarity_score])
        
        results_csv = f"{role}_results.csv"
        fields = ["Name", "Score"]
        with open(results_csv, "w", encoding="utf-8") as f:
            csvwriter = csv.writer(f)
            csvwriter.writerow(fields)
            for name, score in profile_results.items():
                csvwriter.writerow([name, score])
  
        
        # TODO: a array of array should be formed each inner array will contain first element as community_name, and all other elements as member_names of community
        # The count of member_names should be random from 10 to 30, all the member names and community names should be generated by LLM
        # You can provide LLM a prompt like "generate x names" where x is a random number between 10 to 30, also generate a community name
        # For eg:- community_name_list = generate_community_names()
        # community_name_list will contain structure like [
        #                                                   ['Community_name1','Name1', 'Name2', 'Name3', ....,'Name29'],
        #                                                   ['Community_name2','Name1', 'Name2', 'Name3', 'Name4', 'Name5',.....,'Name24'],
        #                                                   ['Community_name3','Name1', 'Name2', 'Name3', .....,'Name 15']]
        # Implement all the function in the LLM class use a module code approach
        # for community
        wmd = WMD(description,f"./Community/{role}")
        top_3_communities = wmd.community_ranking()

        community_results = {}
        for i, (community_name, similarity_score) in enumerate(top_3_communities, 1):
            print(f"Top {i} Community (Similarity Score: {similarity_score}): {community_name}")
            if f'{role}_community' not in final_results:
                final_results[f'{role}_community'] = []
            community_results[community_name] = similarity_score
            final_results[f'{role}_community'].append([community_name, similarity_score, ['name1','name2','name3']])


        community_csv = f'{role}_community.csv'
        fields = ["Name","Score","Names"]
        with open(community_csv, "w", encoding="utf-8") as f:
            csvwriter = csv.writer(f)
            csvwriter.writerow(fields)
            for name, score in community_results.items():
                csvwriter.writerow([name, score, "name1, name2, name3"])

    print(final_results)
    return jsonify(final_results)

if __name__ == "__main__":
    # test("OSMO-DRAIN - the subsurface irrigation system", "100")
    app.run(host="0.0.0.0",debug=True)

#TODO
"""
use llm for generating synthetic names for profiles, for community and for people inside the community
adjust the scores
"""